from typing import Generator, Callable, List, Tuple, Any
from residse.classes.stages.Stage import Stage
from residse.classes.cost_model.cost_model import CostModelEvaluation
from residse.classes.workload.stack import Stack
import logging

logger = logging.getLogger(__name__)


class MinimalEDPStage(Stage):
    """
    Class that keeps yields only the cost model evaluation that has minimal EDP of all cost model evaluations
    generated by it's substages created by list_of_callables
    """
    def __init__(self, list_of_callables, *, keep_others=False, **kwargs):
        super().__init__(list_of_callables, **kwargs)
        self.best_cme = None
        self.keep_others = keep_others

    def run(self):
        """
        Run the compare stage by comparing a new cost model output with the current best found result.
        """
        substage = self.list_of_callables[0](self.list_of_callables[1:], **self.kwargs)
        other_cmes = []
        for cme, extra_info in substage.run():
            cme: CostModelEvaluation
            if self.best_cme is None or cme.edp < self.best_cme.edp:
                self.best_cme = cme     # update best cme
            if self.keep_others:
                other_cmes.append((cme, extra_info))
        yield self.best_cme, other_cmes


class MinimalEnergyStage(Stage):
    """
    Class that keeps yields only the cost model evaluation that has minimal Energy of all cost model evaluations
    generated by it's substages created by list_of_callables
    """
    def __init__(self, list_of_callables, *, keep_others=False, **kwargs):
        super().__init__(list_of_callables, **kwargs)
        self.best_cme = None
        self.keep_others = keep_others

    def run(self):
        """
        Run the compare stage by comparing a new cost model output with the current best found result.
        """
        substage = self.list_of_callables[0](self.list_of_callables[1:], **self.kwargs)
        other_cmes = []
        for cme, extra_info in substage.run():
            cme: CostModelEvaluation
            if self.best_cme is None or cme.en < self.best_cme.en:
                self.best_cme = cme     # update best cme
            if self.keep_others:
                other_cmes.append((cme, extra_info))
        yield self.best_cme, other_cmes


class MinimalLatencyStage(Stage):
    """
    Class that keeps yields only the cost model evaluation that has minimal Latency of all cost model evaluations
    generated by it's substages created by list_of_callables
    """
    def __init__(self, list_of_callables, *, keep_others=False, **kwargs):
        super().__init__(list_of_callables, **kwargs)
        self.best_cme = None
        self.keep_others = keep_others

    def run(self):
        """
        Run the compare stage by comparing a new cost model output with the current best found result.
        """
        substage = self.list_of_callables[0](self.list_of_callables[1:], **self.kwargs)
        other_cmes = []
        for cme, extra_info in substage.run():
            cme: CostModelEvaluation
            if self.best_cme is None or cme.la < self.best_cme.la:
                self.best_cme = cme     # update best cme
            if self.keep_others:
                other_cmes.append((cme, extra_info))
        yield self.best_cme, other_cmes

