from typing import Generator, Callable, List, Tuple, Any
from residse.classes.stages.Stage import Stage
from residse.classes.cost_model.cost_model import CostModelEvaluation
from residse.classes.workload.stack import Stack
import logging

logger = logging.getLogger(__name__)


class MinimalEDPStage(Stage):
    """
    Class that keeps yields only the cost model evaluation that has minimal EDP of all cost model evaluations
    generated by it's substages created by list_of_callables
    """
    def __init__(self, list_of_callables, *, keep_others=False, **kwargs):
        super().__init__(list_of_callables, **kwargs)
        self.keep_others = keep_others

    def run(self):
        """
        Run the compare stage by comparing a new cost model output with the current best found result.
        """
        substage = self.list_of_callables[0](self.list_of_callables[1:], **self.kwargs)
        other_cmes = []
        self.best_cme = None
        for cme, extra_info in substage.run():
            cme: CostModelEvaluation
            if (cme is not None) and (self.best_cme is None or cme.edp < self.best_cme.edp):
                self.best_cme = cme     # update best cme
            if self.keep_others:
                other_cmes.append((cme, extra_info))

        if self.best_cme is not None:
            logger.info(f'tile size for stack {self.best_cme.stack} is {self.best_cme.tile_size}')
        yield self.best_cme, other_cmes


class MinimalEMAStage(Stage):
    """
    Class that keeps yields only the cost model evaluation that has minimal EMA of all cost model evaluations
    generated by it's substages created by list_of_callables
    """
    def __init__(self, list_of_callables, *, keep_others=False, **kwargs):
        super().__init__(list_of_callables, **kwargs)
        self.keep_others = keep_others

    def run(self):
        """
        Run the compare stage by comparing a new cost model output with the current best found result.
        """
        substage = self.list_of_callables[0](self.list_of_callables[1:], **self.kwargs)
        other_cmes = []
        self.best_cme = None
        for cme, extra_info in substage.run():
            cme: CostModelEvaluation
            if (cme is not None) and (self.best_cme is None or cme.ema < self.best_cme.ema):
                self.best_cme = cme     # update best cme
            if self.keep_others:
                other_cmes.append((cme, extra_info))

        if cme is not None:
            logger.info(f'tile size for stack {cme.stack} is {cme.tile_size}')
        yield self.best_cme, other_cmes


class MinimalEnergyStage(Stage):
    """
    Class that keeps yields only the cost model evaluation that has minimal Energy of all cost model evaluations
    generated by it's substages created by list_of_callables
    """
    def __init__(self, list_of_callables, *, keep_others=False, **kwargs):
        super().__init__(list_of_callables, **kwargs)
        self.keep_others = keep_others

    def run(self):
        """
        Run the compare stage by comparing a new cost model output with the current best found result.
        """
        substage = self.list_of_callables[0](self.list_of_callables[1:], **self.kwargs)
        self.best_cme = None
        other_cmes = []
        for cme, extra_info in substage.run():
            cme: CostModelEvaluation
            if (cme is not None) and (self.best_cme is None or cme.en < self.best_cme.en):
                self.best_cme = cme     # update best cme
            if self.keep_others:
                other_cmes.append((cme, extra_info))
        yield self.best_cme, other_cmes


class MinimalLatencyStage(Stage):
    """
    Class that keeps yields only the cost model evaluation that has minimal Latency of all cost model evaluations
    generated by it's substages created by list_of_callables
    """
    def __init__(self, list_of_callables, *, keep_others=False, **kwargs):
        super().__init__(list_of_callables, **kwargs)
        self.keep_others = keep_others

    def run(self):
        """
        Run the compare stage by comparing a new cost model output with the current best found result.
        """
        substage = self.list_of_callables[0](self.list_of_callables[1:], **self.kwargs)
        self.best_cme = None
        other_cmes = []
        for cme, extra_info in substage.run():
            cme: CostModelEvaluation
            if (cme is not None) and (self.best_cme is None or cme.la < self.best_cme.la):
                self.best_cme = cme     # update best cme
            if self.keep_others:
                other_cmes.append((cme, extra_info))
        yield self.best_cme, other_cmes

